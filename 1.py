import pandas as pd
import numpy as np


df = pd.DataFrame({
    'Знания языка программирования': [8, 9, 7, 6, 8, 7, 7],
    'Сложность фреймворка': [7, 6, 8, 5, 6, 6, 6],
    'Сообщество и поддержка': [9, 8, 7, 7, 8, 8, 8],
    'Стоимость': [8, 5, 7, 6, 7, 9, 9]})

df.index = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7']
print(df)

df['Сложность фреймворка'] = 1 / df['Сложность фреймворка']
df['Стоимость'] = 1 / df['Стоимость']

# Создаем массив для хранения результатов попарного сравнения
arr1 = np.zeros((7, 7))
arr1 = arr1.astype("object")
# Попарное сравнение альтернатив
for i in range(7):
    for j in range(i + 1, 7):
        arr = df.iloc[i].values >= df.iloc[j].values  # Сравнение значений всех столбцов для альтернативы i и j
        check = all(x == True for x in arr)  # Проверка, что все критерии для i лучше или равны j
        arr2 = df.iloc[i].values <= df.iloc[j].values  # Сравнение значений всех столбцов для альтернативы i и j
        check2 = all(x == True for x in arr2)  # Проверка, что все критерии для i хуже или равны j
        # Запись результата в массив arr1
        if check == True:
            arr1[j, i] = 'A' + str(i + 1)
        elif check2 == True:
            arr1[j, i] = 'A' + str(j + 1)
        else:
            arr1[j, i] = 'н'

# Создаем новый DataFrame для результатов попарного сравнения
df_ = pd.DataFrame(arr1, columns=['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7'])
# Установка индексов строк DataFrame на новые значения
df_.index = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7']

print("\n Таблица Попарное сравнение альтернатив: ")
print(df_)
print("\n Вывод парето-оптимальных альтернатив")
print(df.iloc[[2, 5, 6]])

df['Сложность фреймворка'] = 1 / df['Сложность фреймворка']
df['Стоимость'] = 1 / df['Стоимость']
print("\n Результат указания верхней/нижней границы: ('Знания языка программирования' >= 8 , 'Сложность фреймворка' <= 6)")
print(df[(df['Знания языка программирования'] >= 8) & (df['Сложность фреймворка'] <= 6)])

print(
    "\n Результат отбора вариантов, удовлетворяющих заданным критериям: главный критерий: Знания языка программирования, Сообщество и поддержка, Стоимость")
print(df[(df['Сложность фреймворка'] >= 6) & (df['Сообщество и поддержка'] <= 8)])


df['Сложность фреймворка'] = 1 / df['Сложность фреймворка']
df['Стоимость'] = 1 / df['Стоимость']


def lex_optimization(df):
    max_crit = df['Знания языка программирования'].max() # Нахождение максимального значения в столбце 'Стаж работы автомаляра (год)'
    optimal_df = df[df['Сообщество и поддержка'] == max_crit] # Фильтрация данных по максимальному значению стажа работы автомаляра

    if len(optimal_df) == 1: # Проверка, если найден только один оптимальный вариант
        return optimal_df

    next_crit = df.loc[optimal_df.index]['Сложность фреймворка'].max() # Нахождение следующего критерия - максимального значения времени выполнения услуги
    optimal_df = optimal_df[optimal_df['Сложность фреймворка'] == next_crit] # Дополнительная фильтрация данных по максимальному значению времени выполнения услуги

    return optimal_df


result = lex_optimization(df)

print("\n Результат лексикографической оптимизации: (Самая важная: Знания языка программирования)")
print(result)